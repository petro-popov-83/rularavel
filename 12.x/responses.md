# HTTP‑ответы {#http-responses}

## Создание ответов {#creating-responses}

В Laravel любой маршрут или метод контроллера должен вернуть ответ, который
посылается в браузер пользователя. Самый простой вариант – вернуть строку
или массив. Строки автоматически упаковываются в полноценный объект
`Response`, а массивы или коллекции моделей превращаются в JSON‑ответы:

```
Route::get('/', function () {
    return 'Привет, мир';
});

Route::get('/numbers', function () {
    return [1, 2, 3]; // превратится в JSON
});
```

Если вам нужна тонкая настройка заголовков и статус‑кода, используйте
фасад `response()` для создания экземпляра `Illuminate\Http\Response`.
Например, можно установить код 200 и заголовок Content‑Type:

```
return response('Привет, мир', 200)
    ->header('Content‑Type', 'text/plain');
```

Laravel позволяет возвращать объекты Eloquent и коллекции прямо из
маршрутов; они будут сериализованы в JSON с учётом скрытых атрибутов
моделей.

### Добавление заголовков

Методы ответов можно цепочкой добавлять дополнительные заголовки. В
простых случаях используйте `header()`, а для нескольких заголовков
воспользуйтесь `withHeaders()`:

```
return response($content)
    ->header('X‑Header‑One', 'Value 1')
    ->header('X‑Header‑Two', 'Value 2');

// то же самое через withHeaders()
return response($content)->withHeaders([
    'X‑Header‑One' => 'Value 1',
    'X‑Header‑Two' => 'Value 2',
]);
```

Laravel также содержит промежуточный слой `cache.headers`, позволяющий
удобно выставить директивы `Cache‑Control` для группы маршрутов.

### Прикрепление cookie {#attaching-cookies}

Чтобы отправить cookie с ответом, вызовите метод `cookie()` и передайте
имя, значение и время действия в минутах. Метод
принимает и дополнительные параметры (путь, домен, флаг безопасности,
только‑HTTP и т. д.) аналогично нативной функции `setcookie()`.

Если вы ещё не создали сам объект ответа, можно «поставить в очередь» cookie
через фасад `Cookie::queue()`, и Laravel автоматически добавит его в
следующий ответ. Сгенерировать объект cookie для
последующего прикрепления поможет глобальная функция `cookie()`.

Удалить cookie можно методом `withoutCookie()`, либо заранее пометив его
устаревшим через `Cookie::expire()`.

#### Шифрование cookies

Посредник `EncryptCookies` по умолчанию шифрует и подписывает все
cookie, чтобы их нельзя было подделать. Если вы хотите исключить
некоторые cookie из шифрования, используйте метод `encryptCookies()` в
закладке `bootstrap/app.php` и передайте массив исключений.

## Перенаправления {#redirects}

Ответы‑перенаправления – экземпляры `Illuminate\Http\RedirectResponse`. Самый
простой способ отправить переадресацию – использовать глобальный хелпер
`redirect()`:

```
Route::get('/dashboard', function () {
    return redirect('/home/dashboard');
});
```

Чтобы вернуть пользователя назад на предыдущий URL (например, после
валидационной ошибки), используйте `back()` – он сохраняет текущий URL
в сессии и перенаправляет пользователя на него.

### Перенаправление на именованные маршруты

Если у маршрута есть имя, используйте метод `route()`:

```
// перенаправление на маршрут «login»
return redirect()->route('login');

// для маршрута /profile/{id}
return redirect()->route('profile', ['id' => 1]);
```

Вы можете передать модель Eloquent вместо ID – Laravel извлечёт ключ
автоматически.

### Перенаправление на действия контроллеров

Метод `action()` принимает массив из класса контроллера и имени
метода. Параметры маршрута передаются вторым
аргументом.

### Внешние домены и флеш‑данные

Для перенаправления на сторонний сайт вызовите `redirect()->away('https://...')`.
Чтобы вместе с переадресацией передать временное сообщение в сессию,
используйте `with()`; для переноса ввода формы – метод
`withInput()`.

## Другие типы ответов {#other-response-types}

### Ответ‑представление

Метод `view()` на фабрике ответов позволяет вернуть представление с
настраиваемым статус‑кодом и заголовками:

```
return response()
    ->view('hello', $data, 200)
    ->header('Content‑Type', $type);
```

### JSON‑ответы

Метод `json()` конвертирует массив в JSON и устанавливает заголовок
`Content‑Type: application/json`. Для JSONP
используйте `withCallback()`.

### Загрузка файлов и вывод файлов

Метод `download()` заставляет браузер скачать файл, а `file()` выводит
файл (например изображение или PDF) прямо в браузере.
При скачивании вы можете указать имя файла и массив заголовков.

## Потоковые ответы {#streamed-responses}

Потоковые ответы позволяют отправлять данные клиенту по мере их
создания, что снижает потребление памяти. Используйте `response()->stream()`
и выведите данные внутри замыкания, вызывая `flush()` после каждой
части. Это полезно при генерации больших
ответов или при работе с API‑чатом.

### Потребление потоков

Для удобного потребления серверных потоков Laravel предлагает пакет
`@laravel/stream-*` для React и Vue. Хук `useStream()` принимает URL и
возвращает состояния `data`, `isFetching`, `isStreaming` и функцию
`send()`. Можно передать опции (ID потока,
начальные данные, заголовки, CSRF‑токен и обработчики событий).
Для отмены текущего стрима вызовите `cancel()`.

### Потоковый JSON

Для трансляции больших наборов данных используйте `streamJson()`, который
постепенно отправляет JSON. Для потребления такого потока используйте
`useJsonStream()`, который автоматически парсит ответ.

### Сервер‑sеnt события (SSE)

Метод `eventStream()` создаёт SSE‑ответ с типом `text/event-stream`.
Замыкание должно yield‑возвращать данные или экземпляры `StreamedEvent` для
задания имени события и данных. Потоки
событий потребляются через хук `useEventStream()` либо через объект
`EventSource` на стороне клиента. Можно
настраивать имя события, обработчики и строку завершения.

### Потоковые загрузки

Метод `streamDownload()` позволяет создать загрузку файла «налету»,
передав в него замыкание, имя файла и заголовки.

## Макросы ответов {#response-macros}

Вы можете определить собственные методы‑макросы для класса ответа,
используя `Response::macro()` в методе `boot()` вашего
поставщика сервисов. Макрос принимает имя и функцию‑замыкание, которая
возвращает готовый ответ. Вызов макроса через хелпер `response()`
позволяет переиспользовать кастомный формат во многих маршрутах.
