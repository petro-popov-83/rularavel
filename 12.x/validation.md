# Проверка данных {#validation}

Laravel предоставляет несколько способов проверки входящих данных запроса. Чаще всего используется метод `validate` объекта `Illuminate\Http\Request`, однако существуют и другие варианты. Фреймворк включает богатую коллекцию правил для проверки строк, чисел, дат, массивов и даже уникальности значений в базе данных, что позволяет быстро проверять входящие данные согласно вашим требованиям【122426402904937†L293-L304】.

## Быстрый старт {#validation-quickstart}

Чтобы понять основные принципы проверки, рассмотрим полный пример проверки формы и отображения ошибок пользователю. Предположим, в файле `routes/web.php` определены маршруты для отображения формы создания записи и её сохранения:

```php
use App\Http\Controllers\PostController;

Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);
```

Контроллер содержит два метода: `create` возвращает представление формы, а `store` сохраняет данные. В методе `store` можно вызвать `$request->validate([...])`, передав массив правил. Если данные удовлетворяют правилам, выполнение кода продолжится; при ошибке будет брошено исключение `Illuminate\Validation\ValidationException` и пользователь будет автоматически перенаправлён назад с сообщениями об ошибке【122426402904937†L429-L489】. Пример:

```php
public function store(Request $request): RedirectResponse
{
    $validated = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body'  => 'required',
    ]);
    // ... запись валидна ...
    return redirect('/posts');
}
```

Правила можно передавать как строку с разделителем `|`, либо как массив строк. Метод `validateWithBag` позволяет указать имя «мешка» ошибок, если нужно разделить ошибки для разных форм【122426402904937†L509-L523】.

### Прекращение проверки при первой ошибке {#bail}

Для атрибутов можно указать правило `bail`, которое остановит выполнение последующих правил после первой ошибки. Например, в цепочке `bail|required|unique:posts|max:255` при ошибке уникальности правило `max` больше не проверяется【122426402904937†L525-L545】.

### Проверка вложенных данных {#nested-attributes}

Если поля формы имеют вложенную структуру (например, объект автора), их имена задаются через точку: `'author.name' => 'required'`. Если имя поля содержит точку как часть ключа, её следует экранировать обратной косой чертой (`'v1\.0'`)【122426402904937†L547-L583】.

## Отображение ошибок {#displaying-validation-errors}

При ошибке проверки Laravel автоматически перенаправляет пользователя на предыдущую страницу и флешит в сессию ошибки и введённые данные. Благодаря посреднику `ShareErrorsFromSession` переменная `$errors` доступна во всех представлениях приложения и является экземпляром `Illuminate\Support\MessageBag`. В Blade-шаблонах можно вывести все ошибки с помощью цикла по `$errors->all()`【122426402904937†L585-L629】. Для проверки ошибки конкретного поля удобно использовать директиву `@error('field') ... @enderror`【122426402904937†L679-L703】.

Для XHR‑запросов метод `validate` не создаёт перенаправление. Вместо этого возвращается JSON‑ответ со статусом 422 и списком ошибок【122426402904937†L670-L677】.

## Пользовательские сообщения и локализация {#customizing-error-messages}

Сообщения об ошибках для встроенных правил хранятся в файле `lang/en/validation.php`. Командой `php artisan lang:publish` можно сгенерировать каталог `lang` и файл локализации. Вы можете редактировать стандартные сообщения или скопировать файл в другую папку (`lang/ru`), чтобы перевести их на русский язык【122426402904937†L651-L668】.

## Создание форм‑запросов {#form-requests}

Для переиспользуемой логики проверки стоит создавать отдельные классы запросов. Команда `php artisan make:request StorePostRequest` создаст класс в `app/Http/Requests`. В нём определяются метод `rules`, возвращающий массив правил, и метод `authorize`, который может проверить права пользователя. В контроллере вместо `$request->validate()` принимается экземпляр этого класса, и проверка запускается автоматически.

Методы `messages` и `attributes` позволяют задать пользовательские сообщения для конкретных правил и переопределить человекочитаемые названия атрибутов.

## Ручная проверка {#manually-creating-validators}

Можно создавать валидаторы вручную через фасад `Validator`:

```php
use Illuminate\Support\Facades\Validator;

$validator = Validator::make($data, [
    'title' => ['required', 'max:255'],
    'body'  => ['required'],
]);

if ($validator->fails()) {
    return back()->withErrors($validator)->withInput();
}
```

Метод `validate` модели `Validator` возвращает проверенные данные, аналогично `Request::validate`. Метод `after` позволяет добавить дополнительные проверки после основных правил, например, связанной модели в базе данных.

## Условные правила {#conditional-validation}

Метод `sometimes` принимает имя поля, массив правил и замыкание, которое определяет, нужно ли применять правила. Это удобно, когда правило зависит от значения другого поля. Также вы можете определить анонимные функции-правила (closures) или классы правил, реализующие интерфейс `Rule`.

## Кастомные правила и объекты Rule {#custom-validation-rules}

Если встроенных правил недостаточно, можно создать собственное правило командой `php artisan make:rule Uppercase`. Класс правила должен реализовывать метод `passes($attribute, $value)` и возвращать `true`/`false`. Сообщение об ошибке задаётся в методе `message`. Для сложных правил с несколькими параметрами можно использовать статические методы класса `Illuminate\Validation\Rules\...`, например:

```php
use Illuminate\Validation\Rules\Password;

$request->validate([
    'password' => ['required', Password::min(8)->letters()->numbers()->mixedCase()->symbols()],
]);
```

## Завершение

Проверка данных — важная часть безопасности и устойчивости приложения. Используйте методы `validate` и `validateWithBag` в контроллерах, создавайте формы‑запросы для сложной логики, выводите сообщения об ошибках через `$errors` и настраивайте локализацию. Не стесняйтесь определять собственные правила, если в стандартном наборе нет нужных.