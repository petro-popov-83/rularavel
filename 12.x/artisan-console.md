# Консоль Artisan {#artisan-console}

## Введение {#introduction}

Artisan — это интерфейс командной строки, входящий в состав Laravel. Скрипт `artisan` находится в корне вашего приложения и предоставляет множество команд, полезных при разработке. Чтобы увидеть список доступных команд, выполните:

```bash
php artisan list
```

Каждая команда имеет экран справки, где описаны её аргументы и параметры. Чтобы просмотреть справку, укажите ключевое слово `help` перед именем команды:

```bash
php artisan help migrate
```

Если вы используете **Laravel Sail** для локальной разработки, не забудьте использовать команду `sail` для вызова Artisan внутри контейнеров Docker, например `./vendor/bin/sail artisan list`.

### Tinker (REPL) {#tinker-repl}

**Laravel Tinker** — это интерактивная среда (REPL) на базе PsySH для работы с вашим приложением. Обычно Tinker устанавливается вместе с Laravel, но его можно добавить отдельно:

```bash
composer require laravel/tinker
```

Запустить Tinker можно командой:

```bash
php artisan tinker
```

В REPL вы можете взаимодействовать с моделями Eloquent, dispatch‑ить задания, публиковать события и т.д. Файл конфигурации `tinker.php` позволяет ограничивать список доступных команд (`commands`) и классов, для которых не следует автоматически создавать псевдонимы (`dont_alias`).

## Создание собственных команд {#writing-commands}

Laravel позволяет создавать собственные консольные команды. Обычно они хранятся в каталоге `app/Console/Commands`. Чтобы сгенерировать новую команду, используйте команду Artisan:

```bash
php artisan make:command SendEmails
```

Этот генератор создаст класс в `app/Console/Commands`. Внутри класса следует определить свойства:

- `signature` — строка, описывающая имя команды, аргументы и опции;
- `description` — краткое описание команды, отображается в списке команд;
- `handle()` — метод, содержащий логику команды. Laravel внедрит зависимости в этот метод автоматически.

Пример команды, отправляющей электронные письма:

```php
namespace App\Console\Commands;

use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Console\Command;

class SendEmails extends Command
{
    protected $signature = 'mail:send {user}';
    protected $description = 'Send a marketing email to a user';

    public function handle(DripEmailer $drip): void
    {
        $drip->send(User::find($this->argument('user')));
    }
}
```

### Возврат кода завершения

Если метод `handle` завершается без возвращаемого значения, команда выходит с кодом `0` (успех). Вы можете вернуть целое число, чтобы указать другой код. Метод `$this->fail()` сразу завершит команду с кодом `1`.

### Команды на замыканиях

Вместо классов можно определить консольные команды в виде замыканий в файле `routes/console.php` с помощью метода `Artisan::command`:

```php
use Illuminate\Support\Facades\Artisan;

Artisan::command('mail:send {user}', function (string $user) {
    $this->info("Sending email to: {$user}!");
})->purpose('Send a marketing email to a user');
```

Замыкание привязывается к экземпляру команды, поэтому в нём доступны все методы `$this->info()`, `$this->error()` и т.д. Вы также можете указать дополнительные зависимости в списке параметров замыкания — они будут разрешены из контейнера.

### Изолируемые команды

Чтобы гарантировать, что команда выполняется только в одном экземпляре, реализуйте интерфейс `Illuminate\Contracts\Console\Isolatable`. Laravel автоматически добавит опцию `--isolated`. При запуске с этой опцией будет создан атомарный замок с использованием выбранного драйвера кэширования. Если замок не удаётся получить, команда не будет выполнена. Вы можете задать код возврата при неудаче (`--isolated=12`).

## Аргументы и опции {#arguments-and-options}

Аргументы и опции задаются прямо в свойстве `signature` или через методы `argument()` и `option()`. В определении команды аргументы заключаются в фигурные скобки, опции — начинаются с `--`. С помощью `*` можно указать, что аргумент или опция принимает несколько значений. Для обязательных аргументов можно предоставить описание через двоеточие:

```php
protected $signature = 'report:generate {year : Year of the report} {--format=pdf : Export format}';
```

Для чтения входных данных используйте `$this->argument('year')`, `$this->option('format')`, `$this->arguments()` (возвращает массив всех аргументов) и `$this->options()` (возвращает массив всех опций). Если аргумент отсутствует, можно переопределить метод `promptForMissingArgumentsUsing()` и вернуть набор вопросов, который будет задан пользователю.

### Взаимодействие с пользователем {#user-interaction}

Команды часто требуют ввода от пользователя. Artisan предоставляет множество методов:

- `$this->ask($question, $default = null)` — запрашивает строку;
- `$this->secret($question)` — запрашивает строку без отображения ввода (например, пароль);
- `$this->confirm($question, $default = false)` — задаёт вопрос «да/нет» и возвращает булев результат;
- `$this->choice($question, array $choices, $default = null, $maxAttempts = null, $allowMultipleSelections = false)` — позволяет выбрать из списка вариантов;
- `$this->anticipate($question, array $choices)` — предлагает варианты автодополнения.

## Вывод информации {#output}

Для вывода текста используйте методы:

- `$this->info($string)` — зелёный цвет для информационных сообщений;
- `$this->warn($string)` — жёлтый цвет для предупреждений;
- `$this->error($string)` — красный цвет для ошибок;
- `$this->line($string, string|null $style = null)` — выводит строку в указанном стиле;
- `$this->table($headers, $rows)` — выводит данные в виде таблицы.

### Индикаторы прогресса

Если нужно показать ход выполнения продолжительной задачи, используйте `withProgressBar()` или класс `ProgressBar`. Первый метод принимает коллекцию и замыкание, которое будет вызвано для каждого элемента, автоматически обновляя шкалу. Также можно создать прогресс‑бар вручную:

```php
$bar = $this->output->createProgressBar(100);
$bar->start();
// ... выполняем работу, обновляя бар ...
$bar->advance();
$bar->finish();
```

## Прослушивание событий и перезапись шаблонов

Artisan предоставляет события `CommandStarting`, `CommandFinished` и `ArtisanCommandExecuted`, которые можно слушать для выполнения дополнительной логики вокруг команд. При генерации команд вы можете настроить шаблоны (stubs), опубликовав их из пакета и изменив под свои нужды. Это позволяет централизованно контролировать стиль генерируемого кода.

Эта глава лишь кратко описывает функциональность Artisan. Более глубокие темы, такие как планировщик команд (Task Scheduling) и очереди, рассмотрены в отдельных разделах.
