# Представления {#views}

## Введение {#introduction}

Возвращать длинные HTML‑строки из маршрутов непрактично. Вместо этого
Laravel использует представления, которые хранятся в каталоге
`resources/views`. Представления позволяют разделить логику контроллеров
и отображения и обычно пишутся с использованием шаблонизатора
. Пример простого шаблона находится в файле
`resources/views/greeting.blade.php`:

```
<!-- greeting.blade.php -->
<html>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>
```

Вернуть это представление можно с помощью хелпера `view('greeting',
['name' => 'James'])`. Многие разработчики
предпочитают создавать интерфейс на React или Vue. Laravel поддерживает
это через библиотеку Inertia, позволяющую привязать React/Vue‑фронтенд к
Laravel‑бекенду без сложности SPA. Для быстрого
старта доступны стартовые наборы React и Vue.

## Создание и рендеринг представлений {#creating-and-rendering-views}

Файлы представлений имеют расширение `.blade.php`. Создать новый
представление можно вручную в `resources/views` или командой:

```
php artisan make:view greeting
```

После создания используйте хелпер `view()` или фасад `View::make()` для
рендеринга, передавая имя шаблона и массив данных.
Имя шаблона соответствует пути без расширения: `admin.profile` будет
искать файл `resources/views/admin/profile.blade.php`.

### Вложенные каталоги

Представления могут располагаться в подпапках. В этом случае для их
обращения используется «точечная» нотация. Например, `view('admin.profile')`
вернёт шаблон из `resources/views/admin/profile.blade.php`.

### Первый доступный шаблон

Если приложение или пакет позволяет переопределять шаблоны, можно
использовать метод `View::first()`, который вернёт первый существующий
шаблон из указанного списка.

### Проверка существования

Метод `View::exists()` возвращает `true`, если шаблон существует. Это
полезно для условной загрузки представления.

## Передача данных представлениям {#passing-data-to-views}

Данные передаются в представления через второй аргумент функции `view`
в виде ассоциативного массива: `view('greeting', ['name' => 'Victoria'])`
. Вместо полного массива можно использовать метод
`with()` для добавления отдельных значений цепочкой:

```
return view('greeting')
    ->with('name', 'Victoria')
    ->with('occupation', 'Astronaut');
```

### Общие данные для всех представлений

Чтобы поделиться данными с каждым шаблоном, зарегистрируйте их в
методе `boot()` сервис‑провайдера через `View::share('key', 'value')`
.

## Компоненты и создатели представлений {#view-composers}

### Композиторы

View composer – это класс или замыкание, которое выполняется при
рендеринге определённого представления. Они помогают централизовать
логику подготовки данных для нескольких шаблонов.
Компонент регистрируется методом `View::composer()` в сервис‑провайдере.
Можно использовать класс‑композитор, у которого метод `compose()` получит
объект представления и добавит данные через `$view->with()`.
В конструктор класса можно внедрять зависимости через контейнер служб.
Компонозитор можно привязать к нескольким шаблонам или ко всем, используя
массив имён или символ `*`.

### Создатели

View creator похож на composer, но вызывается сразу после
инициализации шаблона, а не перед рендерингом. Регистрация
производится методом `View::creator()`.

## Оптимизация представлений {#optimizing-views}

Blade‑шаблоны компилируются по требованию. Laravel автоматически
проверяет наличие и свежесть скомпилированных файлов и при необходимости
перекомпилирует их. Чтобы ускорить развёртывание, можно заранее
скомпилировать все шаблоны командой `php artisan view:cache`.
Очистить кэш компиляции можно через `php artisan view:clear`.
