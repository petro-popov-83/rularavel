# Фасады {#facades}

## Введение {#introduction}

Во многих примерах официальной документации Laravel вы встретите код, который обращается к возможностям фреймворка через «фасады». Фасады предоставляют *статический интерфейс* к классам, зарегистрированным в контейнере служб Laravel. Они служат тонкими прокси для реальных классов, сохраняя при этом тестируемость и гибкость, характерные для внедрения зависимостей. Все фасады Laravel определены в пространстве имён `Illuminate\Support\Facades`, поэтому для использования достаточно добавить импорт, например:

```php
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Route;

Route::get('/cache', function () {
    return Cache::get('key');
});
```

Поскольку фасады предоставляют лаконичный и выразительный синтаксис, примеры в документации часто используют их для демонстрации возможностей фреймворка. Помимо фасадов, Laravel содержит множество глобальных *вспомогательных функций* — такие функции, как `view`, `response`, `url`, `config` и т. д., позволяют выполнять те же действия, что и фасады, но без импорта классов. Например, следующие вызовы полностью эквивалентны:

```php
// Через фасад
return Illuminate\Support\Facades\View::make('profile');

// Через вспомогательную функцию
return view('profile');
```

Нет никакой практической разницы между использованием фасада и вызовом вспомогательной функции; оба варианта обращаются к одному и тому же объекту в контейнере служб и могут быть протестированы одинаковым образом【689972699383240†L304-L343】.

## Когда стоит использовать фасады {#when-to-utilize-facades}

Фасады обладают рядом преимуществ. Они обеспечивают короткий, легко запоминающийся синтаксис, позволяя использовать функции Laravel без необходимости помнить длинные имена классов или вручную внедрять зависимости. Благодаря использованию динамических методов фасады также просто тестировать. Однако важно следить за тем, чтобы ваш класс не превращался в «комбайн»: поскольку фасады не требуют явного внедрения, соблазн использовать их везде может привести к разрастанию класса и нарушению единой ответственности. Если конструктор контроллера или сервиса становится слишком длинным, это сигнал разделить функциональность на несколько меньших классов【689972699383240†L360-L372】.

### Фасады и внедрение зависимостей {#facades-vs-dependency-injection}

Одним из преимуществ внедрения зависимостей является возможность подменять реализации во время тестирования, передавая стаб или мок‑объект. На первый взгляд кажется, что статические методы фасадов не подходят для такого подхода. Однако фасады Laravel используют магический метод `__callStatic()` для перенаправления вызовов к объектам, разрешённым из контейнера, поэтому вы можете тестировать фасады точно так же, как обычные классы. Например, для маршрута, использующего кэш:

```php
use Illuminate\Support\Facades\Cache;

Route::get('/cache', function () {
    return Cache::get('key');
});
```

можно написать тест, который проверит вызов метода `get` с ожидаемыми аргументами:

```php
use Illuminate\Support\Facades\Cache;

test('значение возвращается из кэша', function () {
    Cache::shouldReceive('get')
        ->with('key')
        ->andReturn('value');

    $response = $this->get('/cache');
    $response->assertSee('value');
});
```

Такие тесты работают и при использовании вспомогательных функций, например `cache('key')` — это вызовет тот же метод `get` на объекте кэша, и вы можете проверять вызовы через фасад `Cache`【689972699383240†L360-L567】.

### Фасады и вспомогательные функции {#facades-vs-helper-functions}

Laravel предоставляет множество вспомогательных функций, которые выполняют те же задачи, что и соответствующие фасады (генерация представлений, отправка событий, отправка HTTP‑ответов и т. д.). Например, вызовы `view('profile')` и `Illuminate\Support\Facades\View::make('profile')` эквивалентны — оба обращаются к одной и той же фабрике представлений в контейнере служб. В тестах вы можете перехватывать вызовы к фасаду, даже если в коде используется вспомогательная функция【689972699383240†L488-L569】.

## Как работают фасады {#how-facades-work}

Фасад — это класс, предоставляющий доступ к объекту из контейнера служб. Все фасады Laravel (а также ваши собственные) наследуют базовый класс `Illuminate\Support\Facades\Facade`. Базовый класс использует магический метод `__callStatic()` для перенаправления статических вызовов к экземпляру из контейнера. Рассмотрим пример контроллера:

```php
use Illuminate\Support\Facades\Cache;
use Illuminate\View\View;

class UserController extends Controller
{
    public function showProfile(string $id): View
    {
        $user = Cache::get('user:'.$id);
        return view('profile', ['user' => $user]);
    }
}
```

В классе `Cache` нет статического метода `get`. Вместо этого фасад наследует базовый класс и реализует метод `getFacadeAccessor()`, который возвращает имя привязки в контейнере (в данном случае `cache`). Когда вы вызываете `Cache::get()`, Laravel получает объект службы по имени `cache` из контейнера и вызывает на нём метод `get`【689972699383240†L570-L684】.

## Фасады в реальном времени {#real-time-facades}

Реальные фасады позволяют обращаться к *любой* вашей модели или контракту как к фасаду без необходимости создавать отдельный класс. Чтобы превратить класс в фасад, добавьте префикс `Facades` к пространству имён при импорте. Например, если в модели `Podcast` есть метод `publish`, принимающий экземпляр контракта `Publisher`, вы можете исключить передачу зависимости в каждый вызов, используя реальный фасад:

```php
namespace App\Models;

use App\Contracts\Publisher;
use Facades\App\Contracts\Publisher as PublisherFacade;
use Illuminate\Database\Eloquent\Model;

class Podcast extends Model
{
    public function publish(): void
    {
        $this->update(['publishing' => now()]);
        // Вызовется метод publish у реализованного контракта
        PublisherFacade::publish($this);
    }
}
```

Laravel сам разрешит реализацию контракта `App\Contracts\Publisher` из контейнера. В тестах вы можете мокировать вызов точно так же, как для обычных фасадов:

```php
use App\Models\Podcast;
use Facades\App\Contracts\Publisher;
use Illuminate\Foundation\Testing\RefreshDatabase;

pest()->use(RefreshDatabase::class);

test('подкаст можно опубликовать', function () {
    $podcast = Podcast::factory()->create();
    // Ожидаем, что метод publish будет вызван один раз
    Publisher::shouldReceive('publish')->once()->with($podcast);
    $podcast->publish();
});
```

## Справочник фасадов {#facade-class-reference}

Документация Laravel содержит таблицу, в которой перечислены все стандартные фасады, их базовые классы и ключи привязки в контейнере. В неё входят фасады `App`, `Artisan`, `Auth`, `Blade`, `Cache`, `Config`, `DB`, `Event`, `File`, `Gate`, `Hash`, `Mail`, `Queue`, `Redis`, `Request`, `Response`, `Route`, `Schema`, `Session`, `Storage`, `URL`, `Validator`, `View`, `Vite` и многие другие【689972699383240†L950-L1032】. Этот справочник полезен для быстрой навигации по API документации и выяснения, какой сервис скрывается за фасадом.
