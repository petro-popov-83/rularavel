# Ларавел Фолио

- [Введение](#введение)
- [Установка](#установка)
    - [Пути к страницам/URI](#page-paths-uris)
    - [Маршрутизация субдомена](#маршрутизация субдомена)
- [Создание маршрутов](#creating-routes)
    - [Вложенные маршруты](#nested-routes)
    - [Индексные маршруты](#индексные-маршруты)
- [Параметры маршрута](#route-parameters)
- [Привязка модели маршрута](#route-model-binding)
    - [Мягко удаленные модели](#soft-deleted-models)
- [Рендеринг-хуки](#рендер-хуки)
- [Именованные маршруты](#именованные-маршруты)
- [Промежуточное ПО](#Промежуточное ПО)
- [Кэширование маршрута](#route-caching)

<a name="introduction"></a>
## Введение

[Laravel Folio](https://github.com/laravel/folio) — это мощный страничный маршрутизатор, предназначенный для упрощения маршрутизации в приложениях Laravel. С Laravel Folio создание маршрута становится таким же простым, как создание шаблона Blade в каталоге «resources/views/pages» вашего приложения.

Например, чтобы создать страницу, доступную по URL-адресу `/greeting`, просто создайте файл `greeting.blade.php` в каталоге `resources/views/pages` вашего приложения:

```php
<div>
    Hello World
</div>
```

<a name="установка"></a>
## Установка

Для начала установите Folio в свой проект с помощью менеджера пакетов Composer:

```shell
composer require laravel/folio
```

После установки Folio вы можете выполнить команду Artisan `folio:install`, которая установит поставщика услуг Folio в ваше приложение. Этот поставщик услуг регистрирует каталог, в котором Folio будет искать маршруты/страницы:

```shell
php artisan folio:install
```

<a name="page-paths-uris"></a>
### Пути страниц/URI

По умолчанию Folio обслуживает страницы из каталога `resources/views/pages` вашего приложения, но вы можете настроить эти каталоги с помощью метода `boot` вашего поставщика услуг Folio.

Например, иногда может быть удобно указать несколько путей к фолио в одном приложении Laravel. Возможно, вы захотите создать отдельный каталог страниц фолио для «административной» области вашего приложения, а для остальных страниц вашего приложения использовать другой каталог.

Вы можете сделать это, используя методы Folio::path и Folio::uri. Метод `path` регистрирует каталог, который Folio будет сканировать на наличие страниц при маршрутизации входящих HTTP-запросов, а метод `uri` указывает «базовый URI» для этого каталога страниц:

```php
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages/guest'))->uri('/');

Folio::path(resource_path('views/pages/admin'))
    ->uri('/admin')
    ->middleware([
        '*' => [
            'auth',
            'verified',

            // ...
        ],
    ]);
```

<a name="subdomain-routing"></a>
### Маршрутизация субдоменов

Вы также можете перенаправляться на страницы на основе поддомена входящего запроса. Например, вы можете захотеть направить запросы с `admin.example.com` в другой каталог страниц, чем остальные страницы вашего фолио. Вы можете добиться этого, вызвав метод `domain` после вызова метода `Folio::path`:

```php
use Laravel\Folio\Folio;

Folio::domain('admin.example.com')
    ->path(resource_path('views/pages/admin'));
```

Метод `domain` также позволяет вам захватывать части домена или поддомена в качестве параметров. Эти параметры будут добавлены в шаблон вашей страницы:

```php
use Laravel\Folio\Folio;

Folio::domain('{account}.example.com')
    ->path(resource_path('views/pages/admin'));
```

<a name="creating-routes"></a>
## Создание маршрутов

Вы можете создать маршрут Folio, поместив шаблон Blade в любой из смонтированных каталогов Folio. По умолчанию Folio монтирует каталог «resources/views/pages», но вы можете настроить эти каталоги с помощью метода «boot» вашего поставщика услуг Folio.

Как только шаблон Blade будет помещен в смонтированный каталог Folio, вы сможете сразу же получить к нему доступ через браузер. Например, страница, размещенная в `pages/schedule.blade.php`, может быть доступна в вашем браузере по адресу `http://example.com/schedule`.

Чтобы быстро просмотреть список всех страниц/маршрутов вашего фолио, вы можете вызвать Artisan-команду `folio:list`:

```shell
php artisan folio:list
```

<a name="nested-routes"></a>
### Вложенные маршруты

Вы можете создать вложенный маршрут, создав один или несколько каталогов в одном из каталогов Folio. Например, чтобы создать страницу, доступную через `/user/profile`, создайте шаблон `profile.blade.php` в каталоге `pages/user`:

```shell
php artisan folio:page user/profile

# pages/user/profile.blade.php → /user/profile
```

<a name="index-routes"></a>
### Индексные маршруты

Иногда вам может потребоваться сделать данную страницу «индексом» каталога. Поместив шаблон index.blade.php в каталог Folio, любые запросы к корню этого каталога будут перенаправляться на эту страницу:

```shell
php artisan folio:page index
# pages/index.blade.php → /

php artisan folio:page users/index
# pages/users/index.blade.php → /users
```

<a name="route-parameters"></a>
## Параметры маршрута

Часто вам потребуется вставить сегменты URL-адреса входящего запроса на вашу страницу, чтобы вы могли с ними взаимодействовать. Например, вам может потребоваться доступ к «идентификатору» пользователя, чей профиль отображается. Для этого вы можете заключить часть имени файла страницы в квадратные скобки:

```shell
php artisan folio:page "users/[id]"

# pages/users/[id].blade.php → /users/1
```

Доступ к захваченным сегментам можно получить как переменные в шаблоне Blade:

```html
<div>
    User {{ $id }}
</div>
```

Чтобы захватить несколько сегментов, вы можете поставить перед инкапсулированным сегментом три точки `...`:

```shell
php artisan folio:page "users/[...ids]"

# pages/users/[...ids].blade.php → /users/1/2/3
```

При захвате нескольких сегментов захваченные сегменты будут вставлены на страницу в виде массива:

```html
<ul>
    @foreach ($ids as $id)
        <li>User {{ $id }}</li>
    @endforeach
</ul>
```

<a name="route-model-binding"></a>
## Привязка модели маршрута

Если сегмент подстановочного знака имени файла шаблона вашей страницы соответствует одной из моделей Eloquent вашего приложения, Folio автоматически воспользуется возможностями привязки модели маршрута Laravel и попытается внедрить разрешенный экземпляр модели на вашу страницу:

```shell
php artisan folio:page "users/[User]"

# pages/users/[User].blade.php → /users/1
```

Доступ к захваченным моделям можно получить как переменные в шаблоне Blade. Имя переменной модели будет преобразовано в «верблюжий регистр»:

```html
<div>
    User {{ $user->id }}
</div>
```

#### Настройка ключа

Иногда вам может потребоваться разрешить связанные модели Eloquent, используя столбец, отличный от `id`. Для этого вы можете указать столбец в имени файла страницы. Например, страница с именем файла `[Post:slug].blade.php` попытается разрешить связанную модель через столбец `slug` вместо столбца `id`.

В Windows вам следует использовать `-`, чтобы отделить имя модели от ключа: `[Post-slug].blade.php`.

#### Расположение модели

По умолчанию Folio будет искать вашу модель в каталоге app/Models вашего приложения. Однако при необходимости вы можете указать полное имя класса модели в имени файла вашего шаблона:

```shell
php artisan folio:page "users/[.App.Models.User]"

# pages/users/[.App.Models.User].blade.php → /users/1
```

<a name="soft-deleted-models"></a>
### Мягко удаленные модели

По умолчанию модели, которые были обратимо удалены, не извлекаются при разрешении неявных привязок моделей. Однако, если вы хотите, вы можете поручить Folio получить обратимо удаленные модели, вызвав функцию withTrashed в шаблоне страницы:

```php
<?php

use function Laravel\Folio\{withTrashed};

withTrashed();

?>

<div>
    User {{ $user->id }}
</div>
```

<a name="render-hooks"></a>
## Хуки рендеринга

По умолчанию Folio вернет содержимое шаблона Blade страницы в качестве ответа на входящий запрос. Однако вы можете настроить ответ, вызвав функцию render в шаблоне страницы.

Функция render принимает замыкание, которое получит экземпляр View, визуализируемый Folio, что позволяет вам добавлять дополнительные данные в представление или настраивать весь ответ. Помимо получения экземпляра `View`, любые дополнительные параметры маршрута или привязки модели также будут переданы в замыкание `render`:

```php
<?php

use App\Models\Post;
use Illuminate\Support\Facades\Auth;
use Illuminate\View\View;

use function Laravel\Folio\render;

render(function (View $view, Post $post) {
    if (! Auth::user()->can('view', $post)) {
        return response('Unauthorized', 403);
    }

    return $view->with('photos', $post->author->photos);
}); ?>

<div>
    {{ $post->content }}
</div>

<div>
    This author has also taken {{ count($photos) }} photos.
</div>
```

<a name="named-routes"></a>
## Именованные маршруты

Вы можете указать имя для маршрута данной страницы, используя функцию `name`:

```php
<?php

use function Laravel\Folio\name;

name('users.index');
```

Как и в случае с именованными маршрутами Laravel, вы можете использовать функцию маршрута для создания URL-адресов страниц фолио, которым присвоено имя:

```php
<a href="{{ route('users.index') }}">
    All Users
</a>
```

Если на странице есть параметры, вы можете просто передать их значения функции маршрута:

```php
route('users.show', ['user' => $user]);
```

<a name="промежуточное ПО"></a>
## Промежуточное ПО

Вы можете применить промежуточное программное обеспечение к конкретной странице, вызвав функцию «промежуточное программное обеспечение» в шаблоне страницы:

```php
<?php

use function Laravel\Folio\{middleware};

middleware(['auth', 'verified']);

?>

<div>
    Dashboard
</div>
```

Или, чтобы назначить промежуточное ПО группе страниц, вы можете связать метод «промежуточное ПО» после вызова метода «Folio::path».

Чтобы указать, к каким страницам должно применяться промежуточное программное обеспечение, массив промежуточного программного обеспечения может быть закодирован с использованием соответствующих шаблонов URL-адресов страниц, к которым оно должно применяться. Символ `*` может использоваться как подстановочный знак:

```php
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages'))->middleware([
    'admin/*' => [
        'auth',
        'verified',

        // ...
    ],
]);
```

Вы можете включить замыкания в массив промежуточного программного обеспечения, чтобы определить встроенное анонимное промежуточное программное обеспечение:

```php
use Closure;
use Illuminate\Http\Request;
use Laravel\Folio\Folio;

Folio::path(resource_path('views/pages'))->middleware([
    'admin/*' => [
        'auth',
        'verified',

        function (Request $request, Closure $next) {
            // ...

            return $next($request);
        },
    ],
]);
```

<a name="route-caching"></a>
## Кэширование маршрутов

При использовании Folio вы всегда должны пользоваться [возможностями кэширования маршрутов Laravel](/docs/{{version}}/routing#route-caching). Folio прослушивает команду Artisan `route:cache`, чтобы убедиться, что определения страниц Folio и имена маршрутов правильно кэшируются для максимальной производительности.
