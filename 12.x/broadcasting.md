# Трансляция событий {#broadcasting}

Трансляция (broadcasting) позволяет вашей Laravel‑приложению отправлять события клиентским приложениям через WebSocket‑соединение. Это даёт возможность делиться одними и теми же именами событий и данными между сервером и JavaScript‑приложением, создавая реактивный пользовательский интерфейс. Клиенты подписываются на именованные каналы, а сервер отправляет события в эти каналы. Все настройки и маршруты, связанные с трансляцией, находятся в файлах `config/broadcasting.php` и `routes/channels.php`【872680393823144†L373-L380】.

## Поддерживаемые драйверы {#supported-drivers}

Laravel включает несколько серверных драйверов для трансляции событий: **Laravel Reverb**, **Pusher Channels** и **Ably**. Кроме того, доступен драйвер `log` для локальной разработки и отладки и `null`‑драйвер, который отключает трансляцию во время тестирования【872680393823144†L373-L380】. Каждый драйвер требует некоторых пакетов и настройки переменных окружения.

## Быстрый старт {#quickstart}

По умолчанию трансляция не включена в новых приложениях. Для быстрой настройки используйте Artisan‑команду:

```bash
php artisan install:broadcasting
```

Команда создаст файл `config/broadcasting.php` и файл `routes/channels.php`, где можно определить маршруты авторизации для ваших каналов. При выполнении команды вас попросят выбрать драйвер трансляции (Reverb, Pusher или Ably), а также будут установлены необходимые Composer‑ и NPM‑зависимости и обновлён файл `.env`【872680393823144†L373-L380】. После включения трансляции убедитесь, что запущен worker очереди (`php artisan queue:work`), поскольку трансляция выполняется через очереди【306892849852819†L369-L371】.

## Серверная установка {#server-installation}

### Reverb {#reverb}

Laravel Reverb — это собственный веб‑сокет‑сервер. Для быстрой установки выполните команду:

```bash
php artisan install:broadcasting --reverb
```

Команда установит пакеты Reverb, создаст конфигурацию и обновит `.env`. Можно установить Reverb вручную: `composer require laravel/reverb`, затем выполнить `php artisan reverb:install`, чтобы опубликовать конфигурацию и добавить необходимые переменные окружения【872680393823144†L383-L413】.

### Pusher Channels {#pusher-channels}

Pusher предоставляет управляемый веб‑сокет‑сервис. Чтобы настроить Pusher автоматически, выполните:

```bash
php artisan install:broadcasting --pusher
```

Команда установит SDK PHP и JavaScript и запросит ваши учётные данные Pusher. При ручной установке необходимо установить PHP‑пакет `pusher/pusher-php-server` и заполнить переменные `PUSHER_APP_ID`, `PUSHER_APP_KEY`, `PUSHER_APP_SECRET` и `PUSHER_APP_CLUSTER` в файле `.env`. Далее установите `BROADCAST_CONNECTION=pusher`【872680393823144†L416-L475】.

### Ably {#ably}

Ably — облачный сервис реального времени. Быстрая установка выглядит так:

```bash
php artisan install:broadcasting --ably
```

Команда установит SDK для PHP и JavaScript и попросит ввести ключ Ably. Вы также можете установить пакет вручную командой `composer require ably/ably-php` и задать переменную `ABLY_KEY` в `.env`, после чего установите `BROADCAST_CONNECTION=ably`【872680393823144†L479-L525】.

## Клиентская установка {#client-installation}

На стороне клиента для приёма событий используется библиотека **Laravel Echo**. При использовании команды `install:broadcasting` все необходимые файлы Echo автоматически добавляются в приложение. Для ручной настройки установите зависимости через NPM:

```bash
npm install --save-dev laravel-echo pusher-js
```

или для Reverb — `@reverb/client`, для Ably — `ably`. Инициализируйте Echo в файле `resources/js/bootstrap.js` и укажите соответствующий драйвер и ключи. Например, для Pusher:

```js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';

window.Echo = new Echo({
    broadcaster: 'pusher',
    key: import.meta.env.VITE_PUSHER_APP_KEY,
    cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
    encrypted: true,
});
```

## Определение событий {#defining-broadcast-events}

Чтобы событие транслировалось, класс события должен реализовать интерфейс `ShouldBroadcast`. Этот интерфейс требует реализации метода `broadcastOn()`, который возвращает канал или массив каналов (`Channel`, `PrivateChannel` или `PresenceChannel`), на которые следует отправлять событие【872680393823144†L1364-L1478】. Каналы `Channel` открыты для всех пользователей, а `PrivateChannel` и `PresenceChannel` требуют авторизации.

Пример:

```php
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;

class ServerCreated implements ShouldBroadcast
{
    use SerializesModels;

    public function __construct(public \App\Models\User $user) {}

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('user.'.$this->user->id),
        ];
    }
}
```

### Имя и данные события {#broadcast-name-and-data}

По умолчанию в качестве имени события используется имя его класса. Метод `broadcastAs()` позволяет указать своё имя события; при этом при прослушивании события в Echo имя следует начинать с точки, чтобы избежать добавления пространства имён【872680393823144†L1490-L1520】. Все публичные свойства события автоматически сериализуются и передаются в payload. Для тонкой настройки данных можно определить метод `broadcastWith()`, который возвращает массив данных для отправки【872680393823144†L1532-L1572】.

### Очередь и соединение {#broadcast-queue}

Вы можете указать очередь, в которой будет транслироваться событие, определив свойство `$broadcastQueue` в классе события. Также можно изменить соединение очередей через метод `broadcastVia()` или свойство `$connection` в классе события. Эти параметры позволяют разделять ресурсоёмкие трансляции от других задач.

## Авторизация каналов {#channels}

Маршруты авторизации каналов определяются в файле `routes/channels.php`. Для приватных каналов используйте функцию `Broadcast::channel()` и верните `true`, если пользователь имеет доступ к каналу. Например:

```php
use Illuminate\Support\Facades\Broadcast;

Broadcast::channel('order.{order}', function ($user, $order) {
    return $user->id === $order->user_id;
});
```

Для присутствующих каналов (`PresenceChannel`) используйте такую же функцию, но верните массив данных пользователя (например, имя), который будет виден всем участникам канала. Благодаря этому клиенты могут видеть, кто находится в комнате.

## Прослушивание событий в клиентском приложении {#listening-to-events}

После настройки серверной и клиентской части события можно прослушивать на фронтенде. Например, для приватного канала `user.{id}`:

```js
Echo.private(`user.${userId}`)
    .listen('ServerCreated', (e) => {
        console.log('Сервер создан для пользователя', e.user);
    });
```

Для событий с переопределённым именем используйте точку перед именем: `.listen('.server.created', ...)`【872680393823144†L1518-L1520】. Для присутствующих каналов используйте метод `join()`, который позволяет отслеживать список присутствующих пользователей:

```js
Echo.join(`chat.${roomId}`)
    .here((users) => {
        // список подключенных пользователей
    })
    .joining((user) => {
        // пользователь присоединился
    })
    .leaving((user) => {
        // пользователь покинул канал
    });
```

## Конфигурация {#broadcast-configuration}

Файл `config/broadcasting.php` содержит параметры трансляции. В опции `default` задаётся активный драйвер, а секция `connections` содержит конфигурации для Reverb, Pusher, Ably, `log` и `null`. Во время разработки можно использовать драйвер `log`, который запишет события в лог, а в тестах — драйвер `null` для полного отключения трансляции.

## Заключение {#conclusion}

Laravel упрощает трансляцию событий, позволяя в реальном времени уведомлять клиентов о действиях на сервере. Настройте соответствующий драйвер (Reverb, Pusher или Ably), определите события, авторизуйте каналы, и используйте библиотеку Laravel Echo на клиенте для получения событий. Более подробные инструкции и примеры доступны в официальной документации Laravel【872680393823144†L383-L413】【872680393823144†L416-L475】.